{"ast":null,"code":"\"use strict\";\n\nvar vertexShaderSource = \"#version 300 es\\n\\nprecision highp float;\\n\\n// an attribute is an input (in) to a vertex shader.\\n// It will receive data from a buffer\\nin vec2 a_position;\\nin vec2 a_center;\\nin float a_radius;\\n\\n// Used to pass in the resolution of the canvas\\nuniform vec2 u_resolution;\\n\\nout vec2 v_resolution;\\nout vec2 v_center;\\nout float v_radius;\\n\\n// all shaders have a main function\\nvoid main() {\\n  vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\\n  v_resolution = u_resolution;\\n  v_radius = a_radius;\\n  v_center = a_center;\\n}\\n\";\nvar fragmentShaderSource = \"#version 300 es\\n\\n// fragment shaders don't have a default precision so we need\\n// to pick one. highp is a good default. It means \\\"high precision\\\"\\nprecision highp float;\\n\\n// the texCoords passed in from the vertex shader.\\nin vec2 v_resolution;\\nin vec2 v_center;\\nin float v_radius;\\n\\n// we need to declare an output for the fragment shader\\nout vec4 outColor;\\n\\nvoid main() {\\n  //outColor = texture(u_image, v_texCoord).bgra;\\n  float x = gl_FragCoord.x;\\n  float y = v_resolution[1] - gl_FragCoord.y;\\n  float dx = v_center[0] - x;\\n  float dy = v_center[1] - y;\\n  float distance = sqrt(dx * dx + dy * dy);\\n  if (distance < v_radius)\\n    outColor = vec4(0, 1, 0, 0.05);\\n  else\\n    discard;\\n}\\n\";\nexport function exec(center) {\n  render(center[0], center[1]);\n}\n\nfunction createShader(gl, type, source) {\n  var shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (success) {\n    return shader;\n  }\n\n  console.log(gl.getShaderInfoLog(shader)); // eslint-disable-line\n\n  gl.deleteShader(shader);\n  return undefined;\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (success) {\n    return program;\n  }\n\n  console.log(gl.getProgramInfoLog(program)); // eslint-disable-line\n\n  gl.deleteProgram(program);\n  return undefined;\n}\n\nfunction resizeCanvasToDisplaySize(canvas) {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  var displayWidth = canvas.clientWidth;\n  var displayHeight = canvas.clientHeight; // Check if the canvas is not the same size.\n\n  var needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n}\n\nfunction render(x, y) {\n  // Get A WebGL context\n\n  /** @type {HTMLCanvasElement} */\n  var canvas = document.querySelector(\"#player_canvas\");\n  var gl = canvas.getContext(\"webgl2\");\n\n  if (!gl) {\n    return;\n  } // setup GLSL program\n\n\n  var vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  var fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  var program = createProgram(gl, vShader, fShader); // look up where the vertex data needs to go.\n\n  var positionLocation = gl.getAttribLocation(program, \"a_position\");\n  var centerLocation = gl.getAttribLocation(program, \"a_center\");\n  var radiusLocation = gl.getAttribLocation(program, \"a_radius\"); // lookup uniforms\n\n  var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\"); // Create a vertex array object (attribute state)\n\n  var vao = gl.createVertexArray(); // and make it the one we are currently working with\n\n  gl.bindVertexArray(vao); // Create a buffer and put a single pixel space rectangle in\n  // it (2 triangles)\n\n  var positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Turn on the attribute\n\n  gl.enableVertexAttribArray(positionLocation);\n  gl.enableVertexAttribArray(centerLocation);\n  gl.enableVertexAttribArray(radiusLocation); // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n  //gl.vertexAttribPointer(location, size, type, normalize, stride, offset);\n\n  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 5 * 4, 0);\n  gl.vertexAttribPointer(centerLocation, 2, gl.FLOAT, false, 5 * 4, 8);\n  gl.vertexAttribPointer(radiusLocation, 1, gl.FLOAT, false, 5 * 4, 16);\n  resizeCanvasToDisplaySize(gl.canvas); // Tell WebGL how to convert from clip space to pixels\n\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // Clear the canvas\n\n  gl.clearColor(0, 0, 0, 0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Tell it to use our program (pair of shaders)\n\n  gl.useProgram(program); // Bind the attribute/buffer set we want.\n\n  gl.bindVertexArray(vao); // Pass in the canvas resolution so we can convert from\n  // pixels to clipspace in the shader\n\n  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height); // Bind the position buffer so gl.bufferData that will be called\n  // in setRectangle puts data in the position buffer\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Set a rectangle the same size as the image.\n\n  setCircle(gl, x, y, 3); // Draw the rectangle.\n\n  var primitiveType = gl.TRIANGLES;\n  var offset = 0;\n  var count = 6;\n  gl.drawArrays(primitiveType, offset, count);\n}\n\nfunction setCircle(gl, x, y, r) {\n  var x1 = x - r;\n  var x2 = x + r;\n  var y1 = y - r;\n  var y2 = y + r;\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x, y, r, x2, y1, x, y, r, x1, y2, x, y, r, x1, y2, x, y, r, x2, y1, x, y, r, x2, y2, x, y, r]), gl.STATIC_DRAW);\n}","map":{"version":3,"sources":["/root/svn_work/Splatoon2MapMaster/app/javascript/packs/webgl2/drawCircle.js"],"names":["vertexShaderSource","fragmentShaderSource","exec","center","render","createShader","gl","type","source","shader","shaderSource","compileShader","success","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","undefined","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","resizeCanvasToDisplaySize","canvas","displayWidth","clientWidth","displayHeight","clientHeight","needResize","width","height","x","y","document","querySelector","getContext","vShader","VERTEX_SHADER","fShader","FRAGMENT_SHADER","positionLocation","getAttribLocation","centerLocation","radiusLocation","resolutionLocation","getUniformLocation","vao","createVertexArray","bindVertexArray","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","vertexAttribPointer","FLOAT","viewport","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","useProgram","uniform2f","setCircle","primitiveType","TRIANGLES","offset","count","drawArrays","r","x1","x2","y1","y2","bufferData","Float32Array","STATIC_DRAW"],"mappings":"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","sourcesContent":["\"use strict\";\t\r\nvar vertexShaderSource = `#version 300 es\r\n\r\nprecision highp float;\r\n\r\n// an attribute is an input (in) to a vertex shader.\r\n// It will receive data from a buffer\r\nin vec2 a_position;\r\nin vec2 a_center;\r\nin float a_radius;\r\n\r\n// Used to pass in the resolution of the canvas\r\nuniform vec2 u_resolution;\r\n\r\nout vec2 v_resolution;\r\nout vec2 v_center;\r\nout float v_radius;\r\n\r\n// all shaders have a main function\r\nvoid main() {\r\n  vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\r\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n  v_resolution = u_resolution;\r\n  v_radius = a_radius;\r\n  v_center = a_center;\r\n}\r\n`;\r\n\r\nvar fragmentShaderSource = `#version 300 es\r\n\r\n// fragment shaders don't have a default precision so we need\r\n// to pick one. highp is a good default. It means \"high precision\"\r\nprecision highp float;\r\n\r\n// the texCoords passed in from the vertex shader.\r\nin vec2 v_resolution;\r\nin vec2 v_center;\r\nin float v_radius;\r\n\r\n// we need to declare an output for the fragment shader\r\nout vec4 outColor;\r\n\r\nvoid main() {\r\n  //outColor = texture(u_image, v_texCoord).bgra;\r\n  float x = gl_FragCoord.x;\r\n  float y = v_resolution[1] - gl_FragCoord.y;\r\n  float dx = v_center[0] - x;\r\n  float dy = v_center[1] - y;\r\n  float distance = sqrt(dx * dx + dy * dy);\r\n  if (distance < v_radius)\r\n    outColor = vec4(0, 1, 0, 0.05);\r\n  else\r\n    discard;\r\n}\r\n`;\r\n\r\nexport function exec(center) {\r\n    render(center[0], center[1]);\r\n}\r\n\r\nfunction createShader(gl, type, source) {\r\n  var shader = gl.createShader(type);\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n  if (success) {\r\n    return shader;\r\n  }\r\n\r\n  console.log(gl.getShaderInfoLog(shader));  // eslint-disable-line\r\n  gl.deleteShader(shader);\r\n  return undefined;\r\n}\r\n\r\nfunction createProgram(gl, vertexShader, fragmentShader) {\r\n  var program = gl.createProgram();\r\n  gl.attachShader(program, vertexShader);\r\n  gl.attachShader(program, fragmentShader);\r\n  gl.linkProgram(program);\r\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n  if (success) {\r\n    return program;\r\n  }\r\n\r\n  console.log(gl.getProgramInfoLog(program));  // eslint-disable-line\r\n  gl.deleteProgram(program);\r\n  return undefined;\r\n}\r\n\r\nfunction resizeCanvasToDisplaySize(canvas) {\r\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n  const displayWidth  = canvas.clientWidth;\r\n  const displayHeight = canvas.clientHeight;\r\n \r\n  // Check if the canvas is not the same size.\r\n  const needResize = canvas.width  !== displayWidth ||\r\n                     canvas.height !== displayHeight;\r\n \r\n  if (needResize) {\r\n    // Make the canvas the same size\r\n    canvas.width  = displayWidth;\r\n    canvas.height = displayHeight;\r\n  }\r\n \r\n  return needResize;\r\n}\r\n\r\nfunction render(x, y) {\r\n\r\n // Get A WebGL context\r\n  /** @type {HTMLCanvasElement} */\r\n  var canvas = document.querySelector(\"#player_canvas\");\r\n  var gl = canvas.getContext(\"webgl2\");\r\n  if (!gl) {\r\n    return;\r\n  }\r\n\r\n  // setup GLSL program\r\n  var vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n  var fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n  var program = createProgram(gl, vShader, fShader);\r\n\r\n  // look up where the vertex data needs to go.\r\n  var positionLocation          = gl.getAttribLocation(program, \"a_position\");\r\n  var centerLocation            = gl.getAttribLocation(program, \"a_center\");\r\n  var radiusLocation            = gl.getAttribLocation(program, \"a_radius\");\r\n\r\n  // lookup uniforms\r\n  var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\r\n\r\n  // Create a vertex array object (attribute state)\r\n  var vao = gl.createVertexArray();\r\n\r\n  // and make it the one we are currently working with\r\n  gl.bindVertexArray(vao);\r\n\r\n  // Create a buffer and put a single pixel space rectangle in\r\n  // it (2 triangles)\r\n  var positionBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  // Turn on the attribute\r\n  gl.enableVertexAttribArray(positionLocation);\r\n  gl.enableVertexAttribArray(centerLocation);\r\n  gl.enableVertexAttribArray(radiusLocation);\r\n\r\n  // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n  //gl.vertexAttribPointer(location, size, type, normalize, stride, offset);\r\n  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 5 * 4, 0);\r\n  gl.vertexAttribPointer(centerLocation,   2, gl.FLOAT, false, 5 * 4, 8);\r\n  gl.vertexAttribPointer(radiusLocation,   1, gl.FLOAT, false, 5 * 4, 16);\r\n\r\n  resizeCanvasToDisplaySize(gl.canvas);\r\n\r\n  // Tell WebGL how to convert from clip space to pixels\r\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n  // Clear the canvas\r\n  gl.clearColor(0, 0, 0, 0);\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n  // Tell it to use our program (pair of shaders)\r\n  gl.useProgram(program);\r\n\r\n  // Bind the attribute/buffer set we want.\r\n  gl.bindVertexArray(vao);\r\n\r\n  // Pass in the canvas resolution so we can convert from\r\n  // pixels to clipspace in the shader\r\n  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n  // Bind the position buffer so gl.bufferData that will be called\r\n  // in setRectangle puts data in the position buffer\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  // Set a rectangle the same size as the image.\r\n  setCircle(gl, x, y, 3);\r\n\r\n  // Draw the rectangle.\r\n  var primitiveType = gl.TRIANGLES;\r\n  var offset = 0;\r\n  var count = 6;\r\n  gl.drawArrays(primitiveType, offset, count);\r\n}\r\n\r\nfunction setCircle(gl, x, y, r) {\r\n  var x1 = x - r;\r\n  var x2 = x + r;\r\n  var y1 = y - r;\r\n  var y2 = y + r;\r\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n     x1, y1, x, y, r,\r\n     x2, y1, x, y, r,\r\n     x1, y2, x, y, r,\r\n     x1, y2, x, y, r,\r\n     x2, y1, x, y, r,\r\n     x2, y2, x, y, r\r\n  ]), gl.STATIC_DRAW);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}