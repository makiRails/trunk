{"ast":null,"code":"\"use strict\";\n\nvar vertexShaderSource = \"#version 300 es\\n\\nprecision highp float;\\n\\n// an attribute is an input (in) to a vertex shader.\\n// It will receive data from a buffer\\nin vec2 a_position;\\nin vec2 a_centerFrom;\\nin vec2 a_centerTo;\\nin float a_radiusMin;\\nin float a_radiusMax;\\n\\n// Used to pass in the resolution of the canvas\\nuniform vec2 u_resolution;\\n\\nout vec2 v_resolution;\\nout vec2 v_centerFrom;\\nout vec2 v_centerTo;\\nout float v_radiusMin;\\nout float v_radiusMax;\\n\\n// all shaders have a main function\\nvoid main() {\\n  vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\\n  v_resolution = u_resolution;\\n  v_radiusMin = a_radiusMin;\\n  v_radiusMax = a_radiusMax;\\n  v_centerFrom = a_centerFrom;\\n  v_centerTo = a_centerTo;\\n}\\n\";\nvar fragmentShaderSource = \"#version 300 es\\n\\n#define PI 3.14159265359\\n\\n// fragment shaders don't have a default precision so we need\\n// to pick one. highp is a good default. It means \\\"high precision\\\"\\nprecision highp float;\\n\\n// the texCoords passed in from the vertex shader.\\nin vec2 v_resolution;\\nin vec2 v_centerFrom;\\nin vec2 v_centerTo;\\nin float v_radiusMin;\\nin float v_radiusMax;\\n\\n// we need to declare an output for the fragment shader\\nout vec4 outColor;\\n\\nvoid main() {\\n  //outColor = texture(u_image, v_texCoord).bgra;\\n\\n  float x = gl_FragCoord.x;\\n  float y = v_resolution[1] - gl_FragCoord.y;\\n  float dx1 = x - v_centerFrom[0];\\n  float dy1 = y - v_centerFrom[1];\\n  float d1 = sqrt(dx1 * dx1 + dy1 * dy1);\\n  if ( v_radiusMin < d1 && d1 < v_radiusMax )\\n  {\\n    float dx2 = v_centerTo[0] - v_centerFrom[0];\\n    float dy2 = v_centerTo[1] - v_centerFrom[1];\\n    float d2 = sqrt(dx2 * dx2 + dy2 * dy2);\\n    float rad = acos( ( dx1 * dx2 + dy1 * dy2 ) / ( d1 * d2 ) );\\n    if ( rad * 18.0 <= 3.5 * PI )\\n    {\\n      outColor = vec4(0, 1, 0, 0.3);\\n    }\\n    else\\n    {\\n      discard;\\n    }\\n  }\\n  else\\n  {\\n    discard;\\n  }\\n}\\n\";\nexport function exec(from, to, r) {\n  render(from, to, [6, r * 20]);\n}\n\nfunction createShader(gl, type, source) {\n  var shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (success) {\n    return shader;\n  }\n\n  console.log(gl.getShaderInfoLog(shader)); // eslint-disable-line\n\n  gl.deleteShader(shader);\n  return undefined;\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (success) {\n    return program;\n  }\n\n  console.log(gl.getProgramInfoLog(program)); // eslint-disable-line\n\n  gl.deleteProgram(program);\n  return undefined;\n}\n\nfunction resizeCanvasToDisplaySize(canvas) {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  var displayWidth = canvas.clientWidth;\n  var displayHeight = canvas.clientHeight; // Check if the canvas is not the same size.\n\n  var needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n}\n\nfunction render(from, to, r) {\n  // Get A WebGL context\n\n  /** @type {HTMLCanvasElement} */\n  var canvas = document.querySelector(\"#look_for_canvas\");\n  var gl = canvas.getContext(\"webgl2\", {\n    preserveDrawingBuffer: true,\n    premultipliedAlpha: false\n  });\n\n  if (!gl) {\n    return;\n  } // setup GLSL program\n\n\n  var vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  var fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  var program = createProgram(gl, vShader, fShader); // look up where the vertex data needs to go.\n\n  var positionLocation = gl.getAttribLocation(program, \"a_position\");\n  var centerFromLocation = gl.getAttribLocation(program, \"a_centerFrom\");\n  var centerToLocation = gl.getAttribLocation(program, \"a_centerTo\");\n  var radiusMinLocation = gl.getAttribLocation(program, \"a_radiusMin\");\n  var radiusMaxLocation = gl.getAttribLocation(program, \"a_radiusMax\"); // lookup uniforms\n\n  var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\"); // Create a vertex array object (attribute state)\n\n  var vao = gl.createVertexArray(); // and make it the one we are currently working with\n\n  gl.bindVertexArray(vao); // Create a buffer and put a single pixel space rectangle in\n  // it (2 triangles)\n\n  var positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Turn on the attribute\n\n  gl.enableVertexAttribArray(positionLocation);\n  gl.enableVertexAttribArray(centerFromLocation);\n  gl.enableVertexAttribArray(centerToLocation);\n  gl.enableVertexAttribArray(radiusMinLocation);\n  gl.enableVertexAttribArray(radiusMaxLocation); // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n  //gl.vertexAttribPointer(location, size, type, normalize, stride, offset);\n  // ユニフォームの方がよさげだが\n\n  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 8 * 4, 0);\n  gl.vertexAttribPointer(centerFromLocation, 2, gl.FLOAT, false, 8 * 4, 8);\n  gl.vertexAttribPointer(centerToLocation, 2, gl.FLOAT, false, 8 * 4, 16);\n  gl.vertexAttribPointer(radiusMinLocation, 1, gl.FLOAT, false, 8 * 4, 24);\n  gl.vertexAttribPointer(radiusMaxLocation, 1, gl.FLOAT, false, 8 * 4, 28);\n  resizeCanvasToDisplaySize(gl.canvas); // Tell WebGL how to convert from clip space to pixels\n\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // Clear the canvas\n\n  gl.clearColor(0, 0, 0, 0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Tell it to use our program (pair of shaders)\n\n  gl.useProgram(program); // Bind the attribute/buffer set we want.\n\n  gl.bindVertexArray(vao); // Pass in the canvas resolution so we can convert from\n  // pixels to clipspace in the shader\n\n  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height); // Bind the position buffer so gl.bufferData that will be called\n  // in setRectangle puts data in the position buffer\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Set a rectangle the same size as the image.\n\n  setFan(gl, from, to, r); // Draw the rectangle.\n\n  var primitiveType = gl.TRIANGLES;\n  var offset = 0;\n  var count = 6;\n  gl.drawArrays(primitiveType, offset, count);\n}\n\nfunction setFan(gl, from, to, r) {\n  var x1 = from[0] - r[1];\n  var x2 = from[0] + r[1];\n  var y1 = from[1] - r[1];\n  var y2 = from[1] + r[1];\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, from[0], from[1], to[0], to[1], r[0], r[1], x2, y1, from[0], from[1], to[0], to[1], r[0], r[1], x1, y2, from[0], from[1], to[0], to[1], r[0], r[1], x1, y2, from[0], from[1], to[0], to[1], r[0], r[1], x2, y1, from[0], from[1], to[0], to[1], r[0], r[1], x2, y2, from[0], from[1], to[0], to[1], r[0], r[1]]), gl.STATIC_DRAW);\n}","map":{"version":3,"sources":["/root/svn_work/Splatoon2MapMaster/app/javascript/packs/webgl2/drawFan.js"],"names":["vertexShaderSource","fragmentShaderSource","exec","from","to","r","render","createShader","gl","type","source","shader","shaderSource","compileShader","success","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","undefined","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","resizeCanvasToDisplaySize","canvas","displayWidth","clientWidth","displayHeight","clientHeight","needResize","width","height","document","querySelector","getContext","preserveDrawingBuffer","premultipliedAlpha","vShader","VERTEX_SHADER","fShader","FRAGMENT_SHADER","positionLocation","getAttribLocation","centerFromLocation","centerToLocation","radiusMinLocation","radiusMaxLocation","resolutionLocation","getUniformLocation","vao","createVertexArray","bindVertexArray","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","vertexAttribPointer","FLOAT","viewport","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","useProgram","uniform2f","setFan","primitiveType","TRIANGLES","offset","count","drawArrays","x1","x2","y1","y2","bufferData","Float32Array","STATIC_DRAW"],"mappings":"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","sourcesContent":["\"use strict\";\t\r\nvar vertexShaderSource = `#version 300 es\r\n\r\nprecision highp float;\r\n\r\n// an attribute is an input (in) to a vertex shader.\r\n// It will receive data from a buffer\r\nin vec2 a_position;\r\nin vec2 a_centerFrom;\r\nin vec2 a_centerTo;\r\nin float a_radiusMin;\r\nin float a_radiusMax;\r\n\r\n// Used to pass in the resolution of the canvas\r\nuniform vec2 u_resolution;\r\n\r\nout vec2 v_resolution;\r\nout vec2 v_centerFrom;\r\nout vec2 v_centerTo;\r\nout float v_radiusMin;\r\nout float v_radiusMax;\r\n\r\n// all shaders have a main function\r\nvoid main() {\r\n  vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\r\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n  v_resolution = u_resolution;\r\n  v_radiusMin = a_radiusMin;\r\n  v_radiusMax = a_radiusMax;\r\n  v_centerFrom = a_centerFrom;\r\n  v_centerTo = a_centerTo;\r\n}\r\n`;\r\n\r\nvar fragmentShaderSource = `#version 300 es\r\n\r\n#define PI 3.14159265359\r\n\r\n// fragment shaders don't have a default precision so we need\r\n// to pick one. highp is a good default. It means \"high precision\"\r\nprecision highp float;\r\n\r\n// the texCoords passed in from the vertex shader.\r\nin vec2 v_resolution;\r\nin vec2 v_centerFrom;\r\nin vec2 v_centerTo;\r\nin float v_radiusMin;\r\nin float v_radiusMax;\r\n\r\n// we need to declare an output for the fragment shader\r\nout vec4 outColor;\r\n\r\nvoid main() {\r\n  //outColor = texture(u_image, v_texCoord).bgra;\r\n\r\n  float x = gl_FragCoord.x;\r\n  float y = v_resolution[1] - gl_FragCoord.y;\r\n  float dx1 = x - v_centerFrom[0];\r\n  float dy1 = y - v_centerFrom[1];\r\n  float d1 = sqrt(dx1 * dx1 + dy1 * dy1);\r\n  if ( v_radiusMin < d1 && d1 < v_radiusMax )\r\n  {\r\n    float dx2 = v_centerTo[0] - v_centerFrom[0];\r\n    float dy2 = v_centerTo[1] - v_centerFrom[1];\r\n    float d2 = sqrt(dx2 * dx2 + dy2 * dy2);\r\n    float rad = acos( ( dx1 * dx2 + dy1 * dy2 ) / ( d1 * d2 ) );\r\n    if ( rad * 18.0 <= 3.5 * PI )\r\n    {\r\n      outColor = vec4(0, 1, 0, 0.3);\r\n    }\r\n    else\r\n    {\r\n      discard;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    discard;\r\n  }\r\n}\r\n`;\r\n\r\nexport function exec(from, to, r) {\r\n    render(from, to, [6, r * 20]);\r\n}\r\n\r\nfunction createShader(gl, type, source) {\r\n  var shader = gl.createShader(type);\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n  if (success) {\r\n    return shader;\r\n  }\r\n\r\n  console.log(gl.getShaderInfoLog(shader));  // eslint-disable-line\r\n  gl.deleteShader(shader);\r\n  return undefined;\r\n}\r\n\r\nfunction createProgram(gl, vertexShader, fragmentShader) {\r\n  var program = gl.createProgram();\r\n  gl.attachShader(program, vertexShader);\r\n  gl.attachShader(program, fragmentShader);\r\n  gl.linkProgram(program);\r\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n  if (success) {\r\n    return program;\r\n  }\r\n\r\n  console.log(gl.getProgramInfoLog(program));  // eslint-disable-line\r\n  gl.deleteProgram(program);\r\n  return undefined;\r\n}\r\n\r\nfunction resizeCanvasToDisplaySize(canvas) {\r\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n  const displayWidth  = canvas.clientWidth;\r\n  const displayHeight = canvas.clientHeight;\r\n \r\n  // Check if the canvas is not the same size.\r\n  const needResize = canvas.width  !== displayWidth ||\r\n                     canvas.height !== displayHeight;\r\n \r\n  if (needResize) {\r\n    // Make the canvas the same size\r\n    canvas.width  = displayWidth;\r\n    canvas.height = displayHeight;\r\n  }\r\n \r\n  return needResize;\r\n}\r\n\r\nfunction render(from, to, r) {\r\n\r\n // Get A WebGL context\r\n  /** @type {HTMLCanvasElement} */\r\n  var canvas = document.querySelector(\"#look_for_canvas\");\r\n  var gl = canvas.getContext(\"webgl2\", { preserveDrawingBuffer: true, premultipliedAlpha: false });\r\n  if (!gl) {\r\n    return;\r\n  }\r\n\r\n  // setup GLSL program\r\n  var vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n  var fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n  var program = createProgram(gl, vShader, fShader);\r\n\r\n  // look up where the vertex data needs to go.\r\n  var positionLocation          = gl.getAttribLocation(program, \"a_position\");\r\n  var centerFromLocation        = gl.getAttribLocation(program, \"a_centerFrom\");\r\n  var centerToLocation          = gl.getAttribLocation(program, \"a_centerTo\");\r\n  var radiusMinLocation         = gl.getAttribLocation(program, \"a_radiusMin\");\r\n  var radiusMaxLocation         = gl.getAttribLocation(program, \"a_radiusMax\");\r\n\r\n  // lookup uniforms\r\n  var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\r\n\r\n  // Create a vertex array object (attribute state)\r\n  var vao = gl.createVertexArray();\r\n\r\n  // and make it the one we are currently working with\r\n  gl.bindVertexArray(vao);\r\n\r\n  // Create a buffer and put a single pixel space rectangle in\r\n  // it (2 triangles)\r\n  var positionBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  // Turn on the attribute\r\n  gl.enableVertexAttribArray(positionLocation);\r\n  gl.enableVertexAttribArray(centerFromLocation);\r\n  gl.enableVertexAttribArray(centerToLocation);\r\n  gl.enableVertexAttribArray(radiusMinLocation);\r\n  gl.enableVertexAttribArray(radiusMaxLocation);\r\n\r\n  // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n  //gl.vertexAttribPointer(location, size, type, normalize, stride, offset);\r\n  // ユニフォームの方がよさげだが\r\n  gl.vertexAttribPointer(positionLocation,     2, gl.FLOAT, false, 8 * 4, 0);\r\n  gl.vertexAttribPointer(centerFromLocation,   2, gl.FLOAT, false, 8 * 4, 8);\r\n  gl.vertexAttribPointer(centerToLocation,     2, gl.FLOAT, false, 8 * 4, 16);\r\n  gl.vertexAttribPointer(radiusMinLocation,    1, gl.FLOAT, false, 8 * 4, 24);\r\n  gl.vertexAttribPointer(radiusMaxLocation,    1, gl.FLOAT, false, 8 * 4, 28);\r\n\r\n  resizeCanvasToDisplaySize(gl.canvas);\r\n\r\n  // Tell WebGL how to convert from clip space to pixels\r\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n  // Clear the canvas\r\n  gl.clearColor(0, 0, 0, 0);\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n  // Tell it to use our program (pair of shaders)\r\n  gl.useProgram(program);\r\n\r\n  // Bind the attribute/buffer set we want.\r\n  gl.bindVertexArray(vao);\r\n\r\n  // Pass in the canvas resolution so we can convert from\r\n  // pixels to clipspace in the shader\r\n  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n  // Bind the position buffer so gl.bufferData that will be called\r\n  // in setRectangle puts data in the position buffer\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  // Set a rectangle the same size as the image.\r\n  setFan(gl, from, to, r);\r\n\r\n  // Draw the rectangle.\r\n  var primitiveType = gl.TRIANGLES;\r\n  var offset = 0;\r\n  var count = 6;\r\n  gl.drawArrays(primitiveType, offset, count);\r\n}\r\n\r\nfunction setFan(gl, from, to, r) {\r\n  var x1 = from[0] - r[1];\r\n  var x2 = from[0] + r[1];\r\n  var y1 = from[1] - r[1];\r\n  var y2 = from[1] + r[1];\r\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n     x1, y1, from[0], from[1], to[0], to[1], r[0], r[1],\r\n     x2, y1, from[0], from[1], to[0], to[1], r[0], r[1],\r\n     x1, y2, from[0], from[1], to[0], to[1], r[0], r[1],\r\n     x1, y2, from[0], from[1], to[0], to[1], r[0], r[1],\r\n     x2, y1, from[0], from[1], to[0], to[1], r[0], r[1],\r\n     x2, y2, from[0], from[1], to[0], to[1], r[0], r[1]\r\n  ]), gl.STATIC_DRAW);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}