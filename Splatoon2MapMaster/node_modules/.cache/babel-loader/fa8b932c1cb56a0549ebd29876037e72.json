{"ast":null,"code":"\"use strict\";\n\nvar vertexShaderSource = \"#version 300 es\\n\\n// an attribute is an input (in) to a vertex shader.\\n// It will receive data from a buffer\\nin vec2 a_position;\\nin vec2 a_texCoord;\\n\\n// Used to pass in the resolution of the canvas\\nuniform vec2 u_resolution;\\n\\n// Used to pass the texture coordinates to the fragment shader\\nout vec2 v_texCoord;\\n\\n// all shaders have a main function\\nvoid main() {\\n\\n  // convert the position from pixels to 0.0 to 1.0\\n  vec2 zeroToOne = a_position / u_resolution;\\n\\n  // convert from 0->1 to 0->2\\n  vec2 zeroToTwo = zeroToOne * 2.0;\\n\\n  // convert from 0->2 to -1->+1 (clipspace)\\n  vec2 clipSpace = zeroToTwo - 1.0;\\n\\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\\n\\n  // pass the texCoord to the fragment shader\\n  // The GPU will interpolate this value between points.\\n  v_texCoord = a_texCoord;\\n}\\n\";\nvar fragmentShaderSource = \"#version 300 es\\n\\n// fragment shaders don't have a default precision so we need\\n// to pick one. highp is a good default. It means \\\"high precision\\\"\\nprecision highp float;\\n\\n// our texture\\nuniform sampler2D u_image;\\n\\n// the texCoords passed in from the vertex shader.\\nin vec2 v_texCoord;\\n\\n// we need to declare an output for the fragment shader\\nout vec4 outColor;\\n\\nvoid main() {\\n  //outColor = texture(u_image, v_texCoord).bgra;\\n  outColor = vec4(texture(u_image, v_texCoord).rgb, 0.85);\\n}\\n\";\nexport function exec(filepath) {\n  var image = new Image();\n  image.src = filepath; //\"<%= image_path('area_map/gangaze.png') %>\";\n\n  image.addEventListener('load', function () {\n    render(image);\n  });\n}\n\nfunction createShader(gl, type, source) {\n  var shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (success) {\n    return shader;\n  }\n\n  console.log(gl.getShaderInfoLog(shader)); // eslint-disable-line\n\n  gl.deleteShader(shader);\n  return undefined;\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (success) {\n    return program;\n  }\n\n  console.log(gl.getProgramInfoLog(program)); // eslint-disable-line\n\n  gl.deleteProgram(program);\n  return undefined;\n}\n\nfunction resizeCanvasToDisplaySize(canvas) {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  var displayWidth = canvas.clientWidth;\n  var displayHeight = canvas.clientHeight; // Check if the canvas is not the same size.\n\n  var needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n}\n\nfunction render(image) {\n  // Get A WebGL context\n\n  /** @type {HTMLCanvasElement} */\n  var canvas = document.querySelector(\"#canvas\");\n  var gl = canvas.getContext(\"webgl2\");\n\n  if (!gl) {\n    return;\n  } // setup GLSL program\n\n\n  var vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  var fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  var program = createProgram(gl, vShader, fShader); // look up where the vertex data needs to go.\n\n  var positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n  var texCoordAttributeLocation = gl.getAttribLocation(program, \"a_texCoord\"); // lookup uniforms\n\n  var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n  var imageLocation = gl.getUniformLocation(program, \"u_image\"); // Create a vertex array object (attribute state)\n\n  var vao = gl.createVertexArray(); // and make it the one we are currently working with\n\n  gl.bindVertexArray(vao); // Create a buffer and put a single pixel space rectangle in\n  // it (2 triangles)\n\n  var positionBuffer = gl.createBuffer(); // Turn on the attribute\n\n  gl.enableVertexAttribArray(positionAttributeLocation); // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n\n  var size = 2; // 2 components per iteration\n\n  var type = gl.FLOAT; // the data is 32bit floats\n\n  var normalize = false; // dont normalize the data\n\n  var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\n\n  var offset = 0; // start at the beginning of the buffer\n\n  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset); // provide texture coordinates for the rectangle.\n\n  var texCoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW); // Turn on the attribute\n\n  gl.enableVertexAttribArray(texCoordAttributeLocation); // Tell the attribute how to get data out of texCoordBuffer (ARRAY_BUFFER)\n\n  var size = 2; // 2 components per iteration\n\n  var type = gl.FLOAT; // the data is 32bit floats\n\n  var normalize = false;\n  var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\n\n  var offset = 0; // start at the beginning of the buffer\n\n  gl.vertexAttribPointer(texCoordAttributeLocation, size, type, normalize, stride, offset); // Create a texture.\n\n  var texture = gl.createTexture(); // make unit 0 the active texture uint\n  // (ie, the unit all other texture commands will affect\n\n  gl.activeTexture(gl.TEXTURE0 + 0);\n  gl.bindTexture(gl.TEXTURE_2D, texture); // Set the parameters so we don't need mips and so we're not filtering\n  // and we dont repeat at the edges\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); // Upload the image into the texture.\n\n  var mipLevel = 0; // the largest mip\n\n  var internalFormat = gl.RGBA; // format we want in the texture\n\n  var srcFormat = gl.RGBA; // format of data we are supplying\n\n  var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n\n  gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, image);\n  resizeCanvasToDisplaySize(gl.canvas); // Tell WebGL how to convert from clip space to pixels\n\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // Clear the canvas\n\n  gl.clearColor(0, 0, 0, 0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Tell it to use our program (pair of shaders)\n\n  gl.useProgram(program); // Bind the attribute/buffer set we want.\n\n  gl.bindVertexArray(vao); // Pass in the canvas resolution so we can convert from\n  // pixels to clipspace in the shader\n\n  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height); // Tell the shader to get the texture from texture unit 0\n\n  gl.uniform1i(imageLocation, 0); // Bind the position buffer so gl.bufferData that will be called\n  // in setRectangle puts data in the position buffer\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Set a rectangle the same size as the image.\n\n  setRectangle(gl, 0, 0, image.width, image.height); // Draw the rectangle.\n\n  var primitiveType = gl.TRIANGLES;\n  var offset = 0;\n  var count = 6;\n  gl.drawArrays(primitiveType, offset, count);\n}\n\nfunction setRectangle(gl, x, y, width, height) {\n  var x1 = x;\n  var x2 = x + width;\n  var y1 = y;\n  var y2 = y + height;\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);\n}","map":{"version":3,"sources":["/root/svn_work/Splatoon2MapMaster/app/javascript/packs/webgl2/drawImage2D.js"],"names":["vertexShaderSource","fragmentShaderSource","exec","filepath","image","Image","src","addEventListener","render","createShader","gl","type","source","shader","shaderSource","compileShader","success","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","undefined","createProgram","vertexShader","fragmentShader","program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","resizeCanvasToDisplaySize","canvas","displayWidth","clientWidth","displayHeight","clientHeight","needResize","width","height","document","querySelector","getContext","vShader","VERTEX_SHADER","fShader","FRAGMENT_SHADER","positionAttributeLocation","getAttribLocation","texCoordAttributeLocation","resolutionLocation","getUniformLocation","imageLocation","vao","createVertexArray","bindVertexArray","positionBuffer","createBuffer","enableVertexAttribArray","bindBuffer","ARRAY_BUFFER","size","FLOAT","normalize","stride","offset","vertexAttribPointer","texCoordBuffer","bufferData","Float32Array","STATIC_DRAW","texture","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","mipLevel","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","texImage2D","viewport","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","useProgram","uniform2f","uniform1i","setRectangle","primitiveType","TRIANGLES","count","drawArrays","x","y","x1","x2","y1","y2"],"mappings":"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","sourcesContent":["\"use strict\";\t\r\nvar vertexShaderSource = `#version 300 es\r\n\r\n// an attribute is an input (in) to a vertex shader.\r\n// It will receive data from a buffer\r\nin vec2 a_position;\r\nin vec2 a_texCoord;\r\n\r\n// Used to pass in the resolution of the canvas\r\nuniform vec2 u_resolution;\r\n\r\n// Used to pass the texture coordinates to the fragment shader\r\nout vec2 v_texCoord;\r\n\r\n// all shaders have a main function\r\nvoid main() {\r\n\r\n  // convert the position from pixels to 0.0 to 1.0\r\n  vec2 zeroToOne = a_position / u_resolution;\r\n\r\n  // convert from 0->1 to 0->2\r\n  vec2 zeroToTwo = zeroToOne * 2.0;\r\n\r\n  // convert from 0->2 to -1->+1 (clipspace)\r\n  vec2 clipSpace = zeroToTwo - 1.0;\r\n\r\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n\r\n  // pass the texCoord to the fragment shader\r\n  // The GPU will interpolate this value between points.\r\n  v_texCoord = a_texCoord;\r\n}\r\n`;\r\n\r\nvar fragmentShaderSource = `#version 300 es\r\n\r\n// fragment shaders don't have a default precision so we need\r\n// to pick one. highp is a good default. It means \"high precision\"\r\nprecision highp float;\r\n\r\n// our texture\r\nuniform sampler2D u_image;\r\n\r\n// the texCoords passed in from the vertex shader.\r\nin vec2 v_texCoord;\r\n\r\n// we need to declare an output for the fragment shader\r\nout vec4 outColor;\r\n\r\nvoid main() {\r\n  //outColor = texture(u_image, v_texCoord).bgra;\r\n  outColor = vec4(texture(u_image, v_texCoord).rgb, 0.85);\r\n}\r\n`;\r\n\r\nexport function exec(filepath) {\r\n  var image = new Image();\r\n  image.src = filepath;//\"<%= image_path('area_map/gangaze.png') %>\";\r\n  image.addEventListener('load', function() {\r\n    render(image);\r\n  });\r\n}\r\n\r\nfunction createShader(gl, type, source) {\r\n  var shader = gl.createShader(type);\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n  if (success) {\r\n    return shader;\r\n  }\r\n\r\n  console.log(gl.getShaderInfoLog(shader));  // eslint-disable-line\r\n  gl.deleteShader(shader);\r\n  return undefined;\r\n}\r\n\r\nfunction createProgram(gl, vertexShader, fragmentShader) {\r\n  var program = gl.createProgram();\r\n  gl.attachShader(program, vertexShader);\r\n  gl.attachShader(program, fragmentShader);\r\n  gl.linkProgram(program);\r\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n  if (success) {\r\n    return program;\r\n  }\r\n\r\n  console.log(gl.getProgramInfoLog(program));  // eslint-disable-line\r\n  gl.deleteProgram(program);\r\n  return undefined;\r\n}\r\n\r\nfunction resizeCanvasToDisplaySize(canvas) {\r\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n  const displayWidth  = canvas.clientWidth;\r\n  const displayHeight = canvas.clientHeight;\r\n \r\n  // Check if the canvas is not the same size.\r\n  const needResize = canvas.width  !== displayWidth ||\r\n                     canvas.height !== displayHeight;\r\n \r\n  if (needResize) {\r\n    // Make the canvas the same size\r\n    canvas.width  = displayWidth;\r\n    canvas.height = displayHeight;\r\n  }\r\n \r\n  return needResize;\r\n}\r\n\r\nfunction render(image) {\r\n  // Get A WebGL context\r\n  /** @type {HTMLCanvasElement} */\r\n  var canvas = document.querySelector(\"#canvas\");\r\n  var gl = canvas.getContext(\"webgl2\");\r\n  if (!gl) {\r\n    return;\r\n  }\r\n\r\n  // setup GLSL program\r\n  var vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n  var fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n  var program = createProgram(gl, vShader, fShader);\r\n\r\n  // look up where the vertex data needs to go.\r\n  var positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\r\n  var texCoordAttributeLocation = gl.getAttribLocation(program, \"a_texCoord\");\r\n\r\n  // lookup uniforms\r\n  var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\r\n  var imageLocation = gl.getUniformLocation(program, \"u_image\");\r\n\r\n  // Create a vertex array object (attribute state)\r\n  var vao = gl.createVertexArray();\r\n\r\n  // and make it the one we are currently working with\r\n  gl.bindVertexArray(vao);\r\n\r\n  // Create a buffer and put a single pixel space rectangle in\r\n  // it (2 triangles)\r\n  var positionBuffer = gl.createBuffer();\r\n\r\n  // Turn on the attribute\r\n  gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n  var size = 2;          // 2 components per iteration\r\n  var type = gl.FLOAT;   // the data is 32bit floats\r\n  var normalize = false; // dont normalize the data\r\n  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n  var offset = 0;        // start at the beginning of the buffer\r\n  gl.vertexAttribPointer(\r\n      positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n  // provide texture coordinates for the rectangle.\r\n  var texCoordBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n      0.0,  0.0,\r\n      1.0,  0.0,\r\n      0.0,  1.0,\r\n      0.0,  1.0,\r\n      1.0,  0.0,\r\n      1.0,  1.0,\r\n  ]), gl.STATIC_DRAW);\r\n\r\n  // Turn on the attribute\r\n  gl.enableVertexAttribArray(texCoordAttributeLocation);\r\n\r\n  // Tell the attribute how to get data out of texCoordBuffer (ARRAY_BUFFER)\r\n  var size = 2;          // 2 components per iteration\r\n  var type = gl.FLOAT;   // the data is 32bit floats\r\n  var normalize = false; \r\n  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n  var offset = 0;        // start at the beginning of the buffer\r\n  gl.vertexAttribPointer(\r\n      texCoordAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n  // Create a texture.\r\n  var texture = gl.createTexture();\r\n\r\n  // make unit 0 the active texture uint\r\n  // (ie, the unit all other texture commands will affect\r\n  gl.activeTexture(gl.TEXTURE0 + 0);\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n  // Set the parameters so we don't need mips and so we're not filtering\r\n  // and we dont repeat at the edges\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\r\n  // Upload the image into the texture.\r\n  var mipLevel = 0;               // the largest mip\r\n  var internalFormat = gl.RGBA;   // format we want in the texture\r\n  var srcFormat = gl.RGBA;        // format of data we are supplying\r\n  var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\r\n  gl.texImage2D(gl.TEXTURE_2D,\r\n                mipLevel,\r\n                internalFormat,\r\n                srcFormat,\r\n                srcType,\r\n                image);\r\n\r\n  resizeCanvasToDisplaySize(gl.canvas);\r\n\r\n  // Tell WebGL how to convert from clip space to pixels\r\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n  // Clear the canvas\r\n  gl.clearColor(0, 0, 0, 0);\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n  // Tell it to use our program (pair of shaders)\r\n  gl.useProgram(program);\r\n\r\n  // Bind the attribute/buffer set we want.\r\n  gl.bindVertexArray(vao);\r\n\r\n  // Pass in the canvas resolution so we can convert from\r\n  // pixels to clipspace in the shader\r\n  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n  // Tell the shader to get the texture from texture unit 0\r\n  gl.uniform1i(imageLocation, 0);\r\n\r\n  // Bind the position buffer so gl.bufferData that will be called\r\n  // in setRectangle puts data in the position buffer\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  // Set a rectangle the same size as the image.\r\n  setRectangle(gl, 0, 0, image.width, image.height);\r\n\r\n  // Draw the rectangle.\r\n  var primitiveType = gl.TRIANGLES;\r\n  var offset = 0;\r\n  var count = 6;\r\n  gl.drawArrays(primitiveType, offset, count);\r\n}\r\n\r\nfunction setRectangle(gl, x, y, width, height) {\r\n  var x1 = x;\r\n  var x2 = x + width;\r\n  var y1 = y;\r\n  var y2 = y + height;\r\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n     x1, y1,\r\n     x2, y1,\r\n     x1, y2,\r\n     x1, y2,\r\n     x2, y1,\r\n     x2, y2,\r\n  ]), gl.STATIC_DRAW);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}